# Customised_TLS_Implementation
In this project I have implemented customised TLS to securely communnicate the OTP between bank and client.

## Overview

This project implements a **custom Transport Layer Security (TLS) protocol** in Python, simulating a **secure communication channel** between a client and a server. It involves **key exchange, certificate generation, authentication, and encrypted message transfer** using cryptographic techniques.

## Components

The project consists of three main components:

1. **Trusted Third Party (TTP)** – Acts as a certificate authority (CA) to issue and verify certificates.
2. **Server** – Establishes a secure connection, receives an encrypted message, and decrypts it.
3. **Client** – Initiates communication, selects cryptographic parameters, and securely exchanges messages.

## Workflow

1. **Client requests cipher suite details** from the server.
2. **Server selects cryptographic algorithms** for:
   - Key exchange (e.g., RSA, ECC)
   - Symmetric encryption (e.g., AES, ChaCha20)
   - Hashing (e.g., SHA256, SHA384)
3. **Both generate key pairs** and request **certificates from TTP**.
4. **TTP issues certificates** after verifying public keys.
5. **Mutual certificate verification** between client and server.
6. **Client encrypts and sends a symmetric key** using the agreed key exchange algorithm.
7. **Server decrypts the symmetric key**, ensuring a shared secret.
8. **Server encrypts and sends an OTP message** using symmetric encryption.
9. **Client decrypts the OTP message** for successful communication.

## Key Features

✔ **Secure key exchange** using asymmetric cryptography  
✔ **Mutual authentication** via TTP-issued certificates  
✔ **Encrypted message transmission** using symmetric cryptography  
✔ **Support for multiple cipher suites** (RSA, ECC, AES, ChaCha20)  
✔ **Certificate verification** for secure trust establishment  

## How to Run

1. Open three terminals and start the TTP server:  
   ```bash
   python3 my_ttp.py
   ```
2. Start the server:  
   ```bash
   python3 my_server.py
   ```
3. Start the client:  
   ```bash
   python3 my_client.py
   ```
4. Input cryptographic algorithms (RSA, AES, ChaCha20, SHA256, etc.).
5. Provide required certification details.
6. The client and server exchange messages securely.

## Security Considerations

- The **certificate verification** process needs improvements for stricter validation.
- **Nonce encryption** could enhance security further.
- Additional **error handling and logging** can be implemented.

## References

- [PyOpenSSL Documentation](https://www.pyopenssl.org/en/stable/)  
- [Cryptography Library](https://cryptography.io/en/latest/x509/tutorial/#creating-a-certificate-signing-request-csr)  
- [PyCryptodome Library](https://www.pycryptodome.org/en/latest/)  


## Difficulties
    Many times the implementation of some functionality from one library is good but the related functionality from other library gives an error. As I mentioned earlier padding and unpadding from cryptography was giving erroneous output then specifically using these functionalities from some other library becomes hectic mostly due to compatibility issues.
The same kind of issue I faced during loading and storing the keys and certificates in the directories. Because the formats of storage of one library is good but the keys generated by some other library don’t support that store and load format. Hence it became complete permutation and combination problem.


For more information regarding this project please check the readme-problem-1.pdf and readme-problem-2.pdf files.
